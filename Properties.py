'''
Что это такое?
Геттеры, сеттеры и делитеры — это специальные методы, которые позволяют:

Геттер (@property): Управляет чтением атрибута.
Сеттер (@атрибут.setter): Управляет записью атрибута.
Делитер (@атрибут.deleter): Управляет удалением атрибута.
Эти методы используются для:

Проверки данных перед их записью.
Сокрытия внутренней реализации атрибута.
Добавления дополнительной логики при работе с атрибутом.

Пример: Класс для пользователя с возрастом
Задача:
Создать класс User, где возраст:

Не может быть отрицательным.
Не может превышать 120 лет.
При удалении устанавливается значение по умолчанию (0).
Решение:

class User:
    def __init__(self, name, age):
        self.name = name
        self.age = age  # При инициализации автоматически вызывается сеттер

    # Геттер для age
    @property
    def age(self):
        return self._age  # Возвращает "скрытое" значение _age

    # Сеттер для age
    @age.setter
    def age(self, value):
        if 0 <= value <= 120:
            self._age = value
        else:
            raise ValueError("Возраст должен быть между 0 и 120!")

    # Делитер для age
    @age.deleter
    def age(self):
        print("Возраст удален, устанавливаем значение по умолчанию.")
        self._age = 0  # При удалении возраста устанавливаем 0

# Создаем объект
user = User("Алексей", 37)

# Чтение (используется геттер)
print(user.age)  # Вывод: 37

# Запись (используется сеттер)
user.age = 40  # Проверка на корректность
print(user.age)  # Вывод: 40

# Удаление (используется делитер)
del user.age
print(user.age)  # Вывод: 0 (значение по умолчанию)

Как это работает?
Геттер (@property):
Метод age() без сеттера/делитера работает как геттер .

@property
def age(self):
    return self._age

Сеттер (@age.setter):
Метод с декоратором @age.setter управляет записью значения.

@age.setter
def age(self, value):
    if 0 <= value <= 120:
        self._age = value
    else:
        raise ValueError("Некорректный возраст!")

Делитер (@age.deleter):
Метод с декоратором @age.deleter управляет удалением атрибута.

@age.deleter
def age(self):
    self._age = 0  # Устанавливаем значение по умолчанию

Как использовать: del user.age → автоматически вызывается делитер.

Почему это нужно?
Проверка данных:
Сеттер позволяет проверять корректность данных перед записью.
Пример: user.age = -5 → вызовет ошибку.
Инкапсуляция:
Атрибут _age "скрыт" от прямого доступа. Внешний код работает с user.age, а не с _age.
Дополнительная логика:
Геттер/сеттер могут выполнять вычисления. Например, хранить возраст в днях, но возвращать в годах.
Как это связано со свойствами (@property)?
Свойство — это комбинация геттера, сеттера и делитера, которая позволяет:

Обращаться к атрибуту как к обычной переменной.
При этом скрыть его реализацию и добавить защиту.
Еще примеры
Пример 1: Класс для пароля
class Password:
    def __init__(self, password):
        self.password = password  # Автоматически вызывается сеттер

    @property
    def password(self):
        return self._password  # Возвращаем хэшированный пароль

    @password.setter
    def password(self, value):
        if len(value) >= 8:
            self._password = hash(value)  # Хэшируем пароль перед сохранением
        else:
            raise ValueError("Пароль слишком короткий!")

user = Password("secure123")
print(user.password)  # Вывод: хэш-значение
user.password = "weak"  # ValueError: Пароль слишком короткий!

Пример 2: Класс для координат
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    @property
    def distance(self):
        return (self.x**2 + self.y**2)**0.5  # Вычисляем расстояние на лету

p = Point(3, 4)
print(p.distance)  # Вывод: 5.0 (без сеттера/делитера)
'''