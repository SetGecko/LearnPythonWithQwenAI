'''
Что такое полиморфизм?
Полиморфизм (от греческого "много форм") — это способность объектов разных классов реагировать на вызов одного и того
 же метода по-разному. Это означает, что метод может иметь разное поведение в зависимости от типа объекта,
 который его вызывает.

Например:

У класса Dog метод speak() может возвращать "Гав!".
У класса Cat тот же метод speak() может возвращать "Мяу!".

Зачем нужен полиморфизм?
Универсальность:
Полиморфизм позволяет писать общий код, который работает с объектами разных классов без необходимости знать их
конкретный тип.
Расширяемость:
Если ты добавишь новый класс (например, Bird), он тоже сможет использовать метод speak(), но с другой реализацией.
Простота поддержки:
Ты можешь изменять реализацию методов в дочерних классах, не затрагивая основной код программы.

Как работает полиморфизм?
Пример 1: Базовый полиморфизм
class Dog:
    def speak(self):
        return "Гав!"

class Cat:
    def speak(self):
        return "Мяу!"

# Создаем объекты разных классов
dog = Dog()
cat = Cat()

# Вызываем одинаковый метод
print(dog.speak())  # Вывод: Гав!
print(cat.speak())  # Вывод: Мяу!

Пример 2: Полиморфизм через наследование
class Animal:
    def speak(self):
        return "Животное издает звук"

class Dog(Animal):
    def speak(self):  # Переопределяем метод
        return "Гав!"

class Cat(Animal):
    def speak(self):  # Переопределяем метод
        return "Мяу!"

# Создаем объекты разных классов
dog = Dog()
cat = Cat()

# Вызываем метод через родительский класс
animals = [dog, cat]
for animal in animals:
    print(animal.speak())  # Вывод: Гав!, затем Мяу!

Когда используется полиморфизм?
В работе с коллекциями:
Когда у тебя есть список объектов разных классов, но ты хочешь вызывать у них одинаковые методы.
В интерфейсных классах:
Например, если есть класс Shape (геометрическая фигура) с методом area(), то дочерние классы Rectangle и Circle
могут иметь разные реализации этого метода.
В функциях высшего порядка:
Например, функция process_animals(animals) может принимать список животных и вызывать у каждого метод speak(),
даже если они принадлежат к разным классам.

Пример с наследованием

Базовый класс:
class Vehicle:
    def start_engine(self):
        return "Двигатель запущен"

Дочерние классы:
class Car(Vehicle):
    def start_engine(self):  # Переопределение метода
        return "Автомобильный двигатель запущен"

class Truck(Vehicle):
    def start_engine(self):  # Переопределение метода
        return "Грузовик запускает двигатель"

Использование:
car = Car()
truck = Truck()

vehicles = [car, truck]

for vehicle in vehicles:
    print(vehicle.start_engine())  # Вывод: Автомобильный двигатель запущен, затем Грузовик запускает двигатель

Преимущества полиморфизма
Общие интерфейсы:
Разные классы могут иметь общие методы, что упрощает работу с ними.
Удобство расширения:
Если ты добавишь новый класс (например, Bus), он также сможет использовать метод start_engine().
Читаемость кода:
Полиморфизм делает код более понятным и организованным.

Пример:
class Rectangle:
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def area(self):  # Общий метод
        return self.width * self.height

class Circle:
    def __init__(self, radius):
        self.radius = radius

    def area(self):  # Общий метод
        return 3.14 * self.radius ** 2

# Преимущество: можно работать с разными классами одинаково
shapes = [Rectangle(4, 2), Circle(3)]

for shape in shapes:
    print(shape.area())  # Вывод: 8, затем 28.26
'''

# ==============Задачи на базовый полиморфизм=================
'''
Задача 1: Классы животных
Напиши класс Animal, который будет иметь метод say_sound(). Для разных животных этот метод должен выводить разные звуки.

Алгоритм:

Создай класс Dog с методом say_sound(), который возвращает "Гав!".
Создай класс Cat с методом say_sound(), который возвращает "Мяу!".
Создай список объектов (dog, cat) и вызови метод say_sound() для каждого.
'''
class Animal:
    def speak(self):
        return "Животное издает звук"
class Dog(Animal):
    def speak(self):
        return "Гав!"
class Cat(Animal):
    def speak(self):
        return "Мяу!"


dog = Dog()
cat = Cat()
animals = [dog, cat]
for el in animals:
    print(el.speak())
'''
Задача 2: Классы чисел
Напиши класс Number, который будет хранить число. Метод get_number() должен возвращать это число.

Алгоритм:

Создай класс Number с параметром num в методе __init__.
Определи метод get_number(), который возвращает self.num.
'''

'''
Задача 3: Классы машин
Напиши класс Car, который будет иметь метод start_engine(). Для разных типов машин этот метод должен возвращать разные строки.

Алгоритм:

Создай класс Truck с методом start_engine(), который возвращает "Грузовик запускает двигатель".
Создай класс Sedan с методом start_engine(), который возвращает "Легковой автомобиль запускает двигатель".
Создай список объектов (truck, sedan) и вызови метод start_engine() для каждого.
'''

'''
Задача 4: Классы телефонов
Напиши класс Phone, который будет иметь метод call(). Для разных типов телефонов этот метод должен возвращать разные строки.

Алгоритм:

Создай класс Smartphone с методом call(), который возвращает "Выполняю видеозвонок".
Создай класс BasicPhone с методом call(), который возвращает "Выполняю обычный звонок".
Создай список объектов (smartphone, basic_phone) и вызови метод call() для каждого.
'''

'''
Задача 5: Классы геометрических фигур
Напиши класс Shape, который будет иметь метод area(). Для разных фигур этот метод должен возвращать разные значения площади.

Алгоритм:

Создай класс Rectangle с параметрами width и height в методе __init__.
Определи метод area(), который возвращает self.width * self.height.
Создай класс Circle с параметром radius в методе __init__.
Определи метод area(), который возвращает 3.14 * self.radius ** 2.
Создай список объектов (rectangle, circle) и вызови метод area() для каждого.
'''

'''
Задача 6: Классы пользователей
Напиши класс User, который будет иметь метод can_drive(). Для разных типов пользователей этот метод должен возвращать разные значения.

Алгоритм:

Создай класс Admin с методом can_drive(), который всегда возвращает True.
Создай класс Child с параметром age в методе __init__.
Определи метод can_drive(), который возвращает False, если age < 16.
Создай список объектов (admin, child) и вызови метод can_drive() для каждого.
'''

'''
Задача 7: Классы книг
Напиши класс Book, который будет иметь метод get_info(). Для разных типов книг этот метод должен возвращать разные строки.

Алгоритм:

Создай класс Ebook с параметрами title, author и file_format в методе __init__.
Определи метод get_info(), который возвращает строку "Электронная книга: [название], Автор: [автор], Формат: [формат]".
Создай класс PaperBook с параметрами title, author и pages в методе __init__.
Определи метод get_info(), который возвращает строку "Печатная книга: [название], Автор: [автор], Страниц: [количество страниц]".
Создай список объектов (ebook, paperbook) и вызови метод get_info() для каждого.
'''

'''
Задача 8: Классы городов
Напиши класс City, который будет иметь метод is_megacity(). Для разных типов городов этот метод должен возвращать разные значения.

Алгоритм:

Создай класс Capital с параметрами name и population в методе __init__.
Определи метод is_megacity(), который возвращает True, если population > 5_000_000.
Создай класс SmallCity с параметрами name и population в методе __init__.
Определи метод is_megacity(), который всегда возвращает False.
Создай список объектов (capital, small_city) и вызови метод is_megacity() для каждого.
'''

'''
Задача 9: Классы банковских счетов
Напиши класс BankAccount, который будет иметь метод withdraw(). Для разных типов счетов этот метод должен работать по-разному.

Алгоритм:

Создай класс SavingsAccount с параметром balance в методе __init__.
Определи метод withdraw(amount), который не позволяет снять больше 90% баланса.
Создай класс CreditCard с параметрами balance и limit в методе __init__.
Определи метод withdraw(amount), который проверяет лимит.
Создай список объектов (savings_account, credit_card) и вызови метод withdraw() для каждого.
'''

'''
Задача 10: Классы учебных заведений
Напиши класс School, который будет иметь метод add_student(). Для разных типов заведений этот метод должен работать по-разному.

Алгоритм:

Создай класс University с параметрами name и students в методе __init__.
Определи метод add_student(student, faculty), который добавляет студента только на указанный факультет.
Создай класс Kindergarten с параметрами name и children в методе __init__.
Определи метод add_student(child, age), который добавляет ребенка только если возраст <= 7.
Создай список объектов (university, kindergarten) и вызови метод add_student() для каждого.
'''
