'''
Что такое полиморфизм?
Полиморфизм (от греческого "много форм") — это способность объектов разных классов реагировать на вызов одного и того
 же метода по-разному. Это означает, что метод может иметь разное поведение в зависимости от типа объекта,
 который его вызывает.

Например:

У класса Dog метод speak() может возвращать "Гав!".
У класса Cat тот же метод speak() может возвращать "Мяу!".

Зачем нужен полиморфизм?
Универсальность:
Полиморфизм позволяет писать общий код, который работает с объектами разных классов без необходимости знать их
конкретный тип.
Расширяемость:
Если ты добавишь новый класс (например, Bird), он тоже сможет использовать метод speak(), но с другой реализацией.
Простота поддержки:
Ты можешь изменять реализацию методов в дочерних классах, не затрагивая основной код программы.

Как работает полиморфизм?
Пример 1: Базовый полиморфизм
class Dog:
    def speak(self):
        return "Гав!"

class Cat:
    def speak(self):
        return "Мяу!"

# Создаем объекты разных классов
dog = Dog()
cat = Cat()

# Вызываем одинаковый метод
print(dog.speak())  # Вывод: Гав!
print(cat.speak())  # Вывод: Мяу!

Пример 2: Полиморфизм через наследование
class Animal:
    def speak(self):
        return "Животное издает звук"

class Dog(Animal):
    def speak(self):  # Переопределяем метод
        return "Гав!"

class Cat(Animal):
    def speak(self):  # Переопределяем метод
        return "Мяу!"

# Создаем объекты разных классов
dog = Dog()
cat = Cat()

# Вызываем метод через родительский класс
animals = [dog, cat]
for animal in animals:
    print(animal.speak())  # Вывод: Гав!, затем Мяу!

Когда используется полиморфизм?
В работе с коллекциями:
Когда у тебя есть список объектов разных классов, но ты хочешь вызывать у них одинаковые методы.
В интерфейсных классах:
Например, если есть класс Shape (геометрическая фигура) с методом area(), то дочерние классы Rectangle и Circle
могут иметь разные реализации этого метода.
В функциях высшего порядка:
Например, функция process_animals(animals) может принимать список животных и вызывать у каждого метод speak(),
даже если они принадлежат к разным классам.

Пример с наследованием

Базовый класс:
class Vehicle:
    def start_engine(self):
        return "Двигатель запущен"

Дочерние классы:
class Car(Vehicle):
    def start_engine(self):  # Переопределение метода
        return "Автомобильный двигатель запущен"

class Truck(Vehicle):
    def start_engine(self):  # Переопределение метода
        return "Грузовик запускает двигатель"

Использование:
car = Car()
truck = Truck()

vehicles = [car, truck]

for vehicle in vehicles:
    print(vehicle.start_engine())  # Вывод: Автомобильный двигатель запущен, затем Грузовик запускает двигатель

Преимущества полиморфизма
Общие интерфейсы:
Разные классы могут иметь общие методы, что упрощает работу с ними.
Удобство расширения:
Если ты добавишь новый класс (например, Bus), он также сможет использовать метод start_engine().
Читаемость кода:
Полиморфизм делает код более понятным и организованным.

Пример:
class Rectangle:
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def area(self):  # Общий метод
        return self.width * self.height

class Circle:
    def __init__(self, radius):
        self.radius = radius

    def area(self):  # Общий метод
        return 3.14 * self.radius ** 2

# Преимущество: можно работать с разными классами одинаково
shapes = [Rectangle(4, 2), Circle(3)]

for shape in shapes:
    print(shape.area())  # Вывод: 8, затем 28.26
'''

# ==============Задачи на базовый полиморфизм=================
'''
Задача 1: Классы животных
Напиши класс Animal, который имеет метод speak(). Создай объекты разных классов (Dog, Cat) и вызови у них метод speak().

Алгоритм:

Создай класс Dog с методом speak(), который возвращает "Гав!".
Создай класс Cat с методом speak(), который возвращает "Мяу!".
Создай список объектов и вызови метод speak() у каждого.
'''

'''
Задача 2: Классы книг
Напиши класс Book, который имеет метод get_info(). 
Создай объекты разных классов (Ebook, PaperBook) и вызови у них метод get_info().

Алгоритм:

Создай класс Ebook с методом get_info(), который добавляет информацию о формате.
Создай класс PaperBook с методом get_info(), который добавляет информацию о количестве страниц.
Создай список объектов и вызови метод get_info() у каждого.
'''

'''
Задача 3: Классы машин
Напиши класс Car, который имеет метод start_engine(). 
Создай объекты разных классов (Truck, Sedan) и вызови у них метод start_engine().

Алгоритм:

Создай класс Truck с методом start_engine(), который возвращает строку "Грузовик запускает двигатель".
Создай класс Sedan с методом start_engine(), который возвращает строку "Легковой автомобиль запускает двигатель".
Создай список объектов и вызови метод start_engine() у каждого.
'''

'''
Задача 4: Классы пользователей
Напиши класс User, который имеет метод can_drive(). 
Создай объекты разных классов (Admin, Child) и вызови у них метод can_drive().

Алгоритм:

Создай класс Admin с методом can_drive(), который всегда возвращает True.
Создай класс Child с методом can_drive(), который проверяет возраст (age).
Создай список объектов и вызови метод can_drive() у каждого.
'''

'''
Задача 5: Классы геометрических фигур
Напиши класс Shape, который имеет метод area(). 
Создай объекты разных классов (Rectangle, Circle) и вызови у них метод area().

Алгоритм:

Создай класс Rectangle с методом area(), который вычисляет площадь как width * height.
Создай класс Circle с методом area(), который вычисляет площадь как π * radius^2.
Создай список объектов и вызови метод area() у каждого.
'''

'''
Задача 6: Классы телефонов
Напиши класс Phone, который имеет метод call(). 
Создай объекты разных классов (Smartphone, BasicPhone) и вызови у них метод call().

Алгоритм:

Создай класс Smartphone с методом call(), который поддерживает видеозвонки.
Создай класс BasicPhone с методом call(), который работает только с обычными звонками.
Создай список объектов и вызови метод call() у каждого.
'''

'''
Задача 7: Классы городов
Напиши класс City, который имеет метод is_megacity(). 
Создай объекты разных классов (Capital, SmallCity) и вызови у них метод is_megacity().

Алгоритм:

Создай класс Capital с методом is_megacity(), который считает мегаполисом при населении >5 млн.
Создай класс SmallCity с методом is_megacity(), который всегда возвращает False.
Создай список объектов и вызови метод is_megacity() у каждого.
'''

'''
Задача 8: Классы банковских счетов
Напиши класс BankAccount, который имеет метод withdraw(). 
Создай объекты разных классов (SavingsAccount, CreditCard) и вызови у них метод withdraw().

Алгоритм:

Создай класс SavingsAccount с методом withdraw(), который оставляет хотя бы 10% баланса.
Создай класс CreditCard с методом withdraw(), который проверяет лимит.
Создай список объектов и вызови метод withdraw() у каждого.
'''

'''
Задача 9: Классы кофемашин
Напиши класс CoffeeMachine, который имеет метод make_coffee(). 
Создай объекты разных классов (EspressoMachine, LatteMachine) и вызови у них метод make_coffee().

Алгоритм:

Создай класс EspressoMachine с методом make_coffee(), который делает эспрессо.
Создай класс LatteMachine с методом make_coffee(), который делает капучино.
Создай список объектов и вызови метод make_coffee() у каждого.
'''

'''
Задача 10: Классы учебных заведений
Напиши класс School, который имеет метод add_student(). 
Создай объекты разных классов (University, Kindergarten) и вызови у них метод add_student().

Алгоритм:

Создай класс University с методом add_student(), который принимает факультет студента.
Создай класс Kindergarten с методом add_student(), который проверяет возраст (age).
Создай список объектов и вызови метод add_student() у каждого.
'''
