'''
Что такое полиморфизм?
Полиморфизм (от греческого "много форм") — это способность объектов разных классов реагировать на вызов одного и того
 же метода по-разному. Это означает, что метод может иметь разное поведение в зависимости от типа объекта,
 который его вызывает.

Например:

У класса Dog метод speak() может возвращать "Гав!".
У класса Cat тот же метод speak() может возвращать "Мяу!".

Зачем нужен полиморфизм?
Универсальность:
Полиморфизм позволяет писать общий код, который работает с объектами разных классов без необходимости знать их
конкретный тип.
Расширяемость:
Если ты добавишь новый класс (например, Bird), он тоже сможет использовать метод speak(), но с другой реализацией.
Простота поддержки:
Ты можешь изменять реализацию методов в дочерних классах, не затрагивая основной код программы.

Как работает полиморфизм?
Пример 1: Базовый полиморфизм
class Dog:
    def speak(self):
        return "Гав!"

class Cat:
    def speak(self):
        return "Мяу!"

# Создаем объекты разных классов
dog = Dog()
cat = Cat()

# Вызываем одинаковый метод
print(dog.speak())  # Вывод: Гав!
print(cat.speak())  # Вывод: Мяу!

Пример 2: Полиморфизм через наследование
class Animal:
    def speak(self):
        return "Животное издает звук"

class Dog(Animal):
    def speak(self):  # Переопределяем метод
        return "Гав!"

class Cat(Animal):
    def speak(self):  # Переопределяем метод
        return "Мяу!"

# Создаем объекты разных классов
dog = Dog()
cat = Cat()

# Вызываем метод через родительский класс
animals = [dog, cat]
for animal in animals:
    print(animal.speak())  # Вывод: Гав!, затем Мяу!

Когда используется полиморфизм?
В работе с коллекциями:
Когда у тебя есть список объектов разных классов, но ты хочешь вызывать у них одинаковые методы.
В интерфейсных классах:
Например, если есть класс Shape (геометрическая фигура) с методом area(), то дочерние классы Rectangle и Circle
могут иметь разные реализации этого метода.
В функциях высшего порядка:
Например, функция process_animals(animals) может принимать список животных и вызывать у каждого метод speak(),
даже если они принадлежат к разным классам.

Пример с наследованием

Базовый класс:
class Vehicle:
    def start_engine(self):
        return "Двигатель запущен"

Дочерние классы:
class Car(Vehicle):
    def start_engine(self):  # Переопределение метода
        return "Автомобильный двигатель запущен"

class Truck(Vehicle):
    def start_engine(self):  # Переопределение метода
        return "Грузовик запускает двигатель"

Использование:
car = Car()
truck = Truck()

vehicles = [car, truck]

for vehicle in vehicles:
    print(vehicle.start_engine())  # Вывод: Автомобильный двигатель запущен, затем Грузовик запускает двигатель

Преимущества полиморфизма
Общие интерфейсы:
Разные классы могут иметь общие методы, что упрощает работу с ними.
Удобство расширения:
Если ты добавишь новый класс (например, Bus), он также сможет использовать метод start_engine().
Читаемость кода:
Полиморфизм делает код более понятным и организованным.

Пример:
class Rectangle:
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def area(self):  # Общий метод
        return self.width * self.height

class Circle:
    def __init__(self, radius):
        self.radius = radius

    def area(self):  # Общий метод
        return 3.14 * self.radius ** 2

# Преимущество: можно работать с разными классами одинаково
shapes = [Rectangle(4, 2), Circle(3)]

for shape in shapes:
    print(shape.area())  # Вывод: 8, затем 28.26
'''

# ==============Задачи на базовый полиморфизм=================
'''
Задача 1: Классы животных
Напиши класс Animal, который имеет метод speak(). Создай два дочерних класса: Dog и Cat.

У класса Dog метод speak() должен возвращать "Гав!".
У класса Cat метод speak() должен возвращать "Мяу!".
Алгоритм:

Создай базовый класс Animal с методом speak().
Создай дочерний класс Dog, унаследованный от Animal, и переопредели метод speak().
Создай дочерний класс Cat, унаследованный от Animal, и переопредели метод speak().
'''

'''
Задача 2: Классы книг
Напиши класс Book, который имеет метод get_info(). Создай два дочерних класса: Ebook и PaperBook.

У класса Ebook метод get_info() должен добавлять информацию о формате (например, "PDF").
У класса PaperBook метод get_info() должен добавлять информацию о количестве страниц.
Алгоритм:

Создай базовый класс Book с методом get_info().
Создай дочерний класс Ebook, унаследованный от Book, и переопредели метод get_info().
Создай дочерний класс PaperBook, унаследованный от Book, и переопредели метод get_info().
'''

'''
Задача 3: Классы машин
Напиши класс Car, который имеет метод start_engine(). Создай два дочерних класса: Truck и Sedan.

У класса Truck метод start_engine() должен возвращать строку "Грузовик запускает двигатель".
У класса Sedan метод start_engine() должен возвращать строку "Легковой автомобиль запускает двигатель".
Алгоритм:

Создай базовый класс Car с методом start_engine().
Создай дочерний класс Truck, унаследованный от Car, и переопредели метод start_engine().
Создай дочерний класс Sedan, унаследованный от Car, и переопредели метод start_engine().
'''

'''
Задача 4: Классы пользователей
Напиши класс User, который имеет метод can_drive(). Создай два дочерних класса: Admin и Child.

У класса Admin метод can_drive() всегда должен возвращать True.
У класса Child метод can_drive() должен проверять возраст (age) и возвращать False, если возраст меньше 16.
Алгоритм:

Создай базовый класс User с методом can_drive().
Создай дочерний класс Admin, унаследованный от User, и переопредели метод can_drive().
Создай дочерний класс Child, унаследованный от User, и переопредели метод can_drive().
'''

'''
Задача 5: Классы геометрических фигур
Напиши класс Shape, который имеет метод area(). Создай два дочерних класса: Rectangle и Circle.

У класса Rectangle метод area() должен вычислять площадь как width * height.
У класса Circle метод area() должен вычислять площадь как π * radius^2.
Алгоритм:

Создай базовый класс Shape с методом area().
Создай дочерний класс Rectangle, унаследованный от Shape, и переопредели метод area().
Создай дочерний класс Circle, унаследованный от Shape, и переопредели метод area().
'''

'''
Задача 6: Классы телефонов
Напиши класс Phone, который имеет метод call(). Создай два дочерних класса: Smartphone и BasicPhone.

У класса Smartphone метод call() должен поддерживать видеозвонки.
У класса BasicPhone метод call() должен работать только с обычными звонками.
Алгоритм:

Создай базовый класс Phone с методом call().
Создай дочерний класс Smartphone, унаследованный от Phone, и переопредели метод call().
Создай дочерний класс BasicPhone, унаследованный от Phone, и переопредели метод call().
'''

'''
Задача 7: Классы городов
Напиши класс City, который имеет метод is_megacity(). Создай два дочерних класса: Capital и SmallCity.

У класса Capital метод is_megacity() должен считать город мегаполисом при населении >5 млн.
У класса SmallCity метод is_megacity() всегда должен возвращать False.
Алгоритм:

Создай базовый класс City с методом is_megacity().
Создай дочерний класс Capital, унаследованный от City, и переопредели метод is_megacity().
Создай дочерний класс SmallCity, унаследованный от City, и переопредели метод is_megacity().
'''

'''
Задача 8: Классы банковских счетов
Напиши класс BankAccount, который имеет метод withdraw(). Создай два дочерних класса: SavingsAccount и CreditCard.

У класса SavingsAccount метод withdraw() должен оставлять хотя бы 10% баланса.
У класса CreditCard метод withdraw() должен проверять лимит.
Алгоритм:

Создай базовый класс BankAccount с методом withdraw().
Создай дочерний класс SavingsAccount, унаследованный от BankAccount, и переопредели метод withdraw().
Создай дочерний класс CreditCard, унаследованный от BankAccount, и переопредели метод withdraw().
'''

'''
Задача 9: Классы кофемашин
Напиши класс CoffeeMachine, который имеет метод make_coffee(). Создай два дочерних класса: EspressoMachine и LatteMachine.

У класса EspressoMachine метод make_coffee() должен делать эспрессо.
У класса LatteMachine метод make_coffee() должен делать капучино.
Алгоритм:

Создай базовый класс CoffeeMachine с методом make_coffee().
Создай дочерний класс EspressoMachine, унаследованный от CoffeeMachine, и переопредели метод make_coffee().
Создай дочерний класс LatteMachine, унаследованный от CoffeeMachine, и переопредели метод make_coffee().
'''

'''
Задача 10: Классы учебных заведений
Напиши класс School, который имеет метод add_student(). Создай два дочерних класса: University и Kindergarten.

У класса University метод add_student() должен принимать факультет студента.
У класса Kindergarten метод add_student() должен проверять возраст (age) и добавлять только детей до 7 лет.
Алгоритм:

Создай базовый класс School с методом add_student().
Создай дочерний класс University, унаследованный от School, и переопредели метод add_student().
Создай дочерний класс Kindergarten, унаследованный от School, и переопредели метод add_student().
'''